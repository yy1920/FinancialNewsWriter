from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain_google_genai import GoogleGenerativeAI
from langchain.memory import ConversationBufferMemory
from langchain.vectorstores import FAISS
from langchain.embeddings import HuggingFaceEmbeddings
from langchain.chains.qa_with_sources import load_qa_with_sources_chain
import yfinance as yf
from playwright.sync_api import sync_playwright
import trafilatura
from langchain_core.documents import Document
from googlesearch import search
from playwright.sync_api import sync_playwright
import trafilatura
import requests
from playwright_stealth import stealth_sync
from GoogleNews import GoogleNews
import datetime as dt
import ssl
import streamlit as st
import pandas as pd

from langchain.prompts import PromptTemplate

class MainOrchestrator:
    """
    Main orchestrator agent that directs tasks to other agents based on user input.
    """
    def __init__(self, company_name, stock_name):
        self.company_name = company_name
        self.stock_name = stock_name
        self.memory = ConversationBufferMemory()  # Maintains the conversation context
        self.research_agent = ResearchAgent()
        self.writer_agent = WriterAgent()
        self.coding_agent = CodingAgent()
        self.trader_agent = TraderAgent()

    def process_input(self, user_input: str):
        """
        Analyze user input and delegate tasks to appropriate agents.
        :user_input: The user query or input.
        :return: The response generated by the relevant agent(s).
        """
        if "news" in user_input.lower():
            articles = self.research_agent.get_news(self.company_name)
            return f"Latest articles: {articles}"
        elif "write" in user_input.lower():
            articles = self.research_agent.get_news(self.company_name)
            return self.writer_agent.write_article(self.company_name, articles)
        elif "stock" in user_input.lower():
            stock_data = self.coding_agent.get_stock_data(self.stock_name)
            indicators = self.coding_agent.calculate_indicators(stock_data)
            return indicators
        elif "trade" in user_input.lower():
            stock_data = self.coding_agent.get_stock_data(self.stock_name)
            indicators = self.coding_agent.calculate_indicators(stock_data)
            return self.trader_agent.suggest_trade(indicators)
        else:
            return "I didn't understand your request. Try asking about news, writing, stock prices, or trading."


class ResearchAgent:
    def get_urls(self, company_name):
        ssl._create_default_https_context = ssl._create_unverified_context

        now = dt.date.today()
        now = now.strftime('%m-%d-%Y')
        yesterday = dt.date.today() - dt.timedelta(days = 30)
        yesterday = yesterday.strftime('%m-%d-%Y')

        company_name = f"{company_name} Finance News"
        googlenews = GoogleNews(start=yesterday,end=now)
        googlenews.search(company_name)
        return [i['link'][:i['link'].find("&ved")] for i in googlenews.result()]
    
    def get_news(self, company_name):
        articles = []
        #query = f"{company_name} company news"
        #search_results = search(query, num_results=5)
        search_results = self.get_urls(company_name=company_name)

        with sync_playwright() as p:
            browser = p.chromium.launch(headless=False, args=["--ignore-certificate-errors"])
            page = browser.new_page()
            page.set_default_timeout(60000)

            # Apply stealth
            stealth_sync(page)

            page.set_extra_http_headers({
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Accept-Language": "en-US,en;q=0.9",
                "Referer": "https://www.google.com/"
            })
            for url in search_results:
                for attempt in range(3):
                    try:
                        page.goto(url, wait_until="domcontentloaded")
                        final_url = page.url
                        if final_url != url:
                            print(f"Redirect detected: {url} -> {final_url}")
                        # Dismiss the cookies banner
                        try:
                            # Replace the selector with the specific button used to dismiss the banner
                            page.get_by_role('button').get_by_text('Reject all').click(timeout=2_000)
                            # redirect after rejecting cookies
                            page.goto(url, wait_until="domcontentloaded")
                            final_url = page.url
                            if final_url != url:
                                print(f"Redirect detected: {url} -> {final_url}")
                        except Exception as e:
                            print(f"No cookies banner to dismiss: {e}")
                        html_content = page.content()
                        extracted_content = trafilatura.extract(html_content)

                        if extracted_content:
                            title = page.title() if page.title() else "No title available"
                            articles.append(Document(
                                page_content=extracted_content,
                                metadata={"source":final_url, "headline":title}
                            ))
                        break  # Exit retry loop on success
                    except Exception as e:
                        print(f"Attempt {attempt + 1} failed for {url}: {e}")
                else:
                    # Fallback to requests if Playwright fails
                    try:
                        response = requests.get(url, timeout=10, headers={
                            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
                        })
                        response.raise_for_status()
                        html_content = response.text
                        extracted_content = trafilatura.extract(html_content)
                        if extracted_content:
                            articles.append(Document(
                                page_content=extracted_content,
                                metadata={"source":final_url, "headline":''}
                            ))
                    except Exception as e:
                        print(f"Fallback failed for {url}: {e}")

            browser.close()

        return articles


class WriterAgent:
    """
    Agent for writing articles with RAG
    """
    def __init__(self):
        self.llm = GoogleGenerativeAI(model="gemini-1.5-flash", temperature=0.5)
        self.embeddings = HuggingFaceEmbeddings()  # Initialize Huggingface embeddings
        self.database = None

    def build_database(self, content):
       
        self.database = FAISS.from_documents(content, self.embeddings)

    def write_article(self, company_name, content):
        
        if not content:
            return "No content available to write an article."

        self.build_database(content)

        chain = load_qa_with_sources_chain(self.llm, chain_type="stuff")
        query = f"Write an article about {company_name}. If there is trading advice, state it with the source."
        response = chain.invoke(
            {
                "input_documents": self.database.similarity_search(query, k=5),
                "question": query,
            }
        )
        return response


class CodingAgent:
    """
    Agent calculates indicators 
    """
    def get_stock_data(self, stock_name):
        
        ticker = yf.Ticker(stock_name)
        return ticker.history(period="1mo")

    def calculate_indicators(self, stock_data):
        """
        Calculate stock price indicators like moving averages.
        stock_data: Stock price data.

        return: Calculated indicators as a description.
        """
        stock_data["SMA20"] = stock_data["Close"].rolling(window=20).mean()
        stock_data["SMA50"] = stock_data["Close"].rolling(window=50).mean()

        return stock_data.tail()


class TraderAgent:
    """
    Trading agent suggests trading strategies based on stock indicators.
    """
    def suggest_trade(self, indicators):
        
        # Simplified trading strategy example
        if "SMA20" in indicators and "SMA50" in indicators:
            return "Based on the indicators, consider buying if SMA20 > SMA50, selling if SMA20 < SMA50."
        else:
            return "Not enough data to provide a trading suggestion."



if __name__ == "__main__":
    company_name = "Apple"
    stock_name = "AAPL"
    orchestrator = MainOrchestrator(company_name, stock_name)
    st.header("Stock Explorer")
    orchestrator.process_input("Get news")
    article = orchestrator.process_input("Write an article")
    with st.expander(f"{company_name} News"):
        st.write(article['output_text'])
    with st.expander(f"Stock Data"):
        st.write(orchestrator.process_input("Get stock data"))
    #with st.expander("Trade Advice"):
    #    st.write(orchestrator.process_input("Suggest a trade"))
    #chat = ChatWithStockData(stock_name)
